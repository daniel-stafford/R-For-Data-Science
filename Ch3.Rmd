---
title: "Ch3"
output: html_document
date: "2024-03-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd('/Users/danielstafford/Coding/Tutorials/R-For-Data-Science')
getwd()
```

```{r}
if (!require('nycflights13')) install.packages('nycflights13')
if (!require('Lahman')) install.packages('Lahman')

library(nycflights13)
library(tidyverse)
library(dplyr)
library(Lahman)

#  Conflicts with filter and lag. If you want to use the base version of these functions after loading dplyr, you’ll need to use their full names: stats::filter() and stats::lag().
```

```{r explore data}
?flights
flights
View(flights)
glimpse(flights) # <int> is short for integer, <dbl> is short for double (aka real numbers), <chr> for character (aka strings), and <dttm> for date-time.
```

```{r 3.1.3 dplyr basics}
flights |>
  filter(dest == "IAH") |> 
  group_by(year, month, day) |> 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )

# find all flights that departed more than 120 minutes (two hours) late:
flights |> 
  filter(dep_delay > 120)


# Flights that departed on January 1
flights |> 
  filter(month == 1 & day == 1)

# Flights that departed in January or February
flights |> 
  filter(month == 1 | month == 2)

# A shorter way to select flights that departed in January or February
flights |> 
  filter(month %in% c(1, 2))

flights |>
  filter(month %in% c(11,12))

feb <- flights |>
  filter(month == 2)
feb

flights |> 
  arrange(year, month, day, dep_delay, dep_time)

flights |> 
  arrange(desc(dep_delay))

# 3.2.4 distinct() 
flights |> 
  distinct() # remove any duplicate rows

# Find all unique origin and destination pairs
flights |> 
  distinct(origin, dest)

# eep other columns when filtering for unique rows, you can use the .keep_all = TRUE option.
flights |> 
  distinct(origin, dest, .keep_all = TRUE)

flights |>
  count(origin, dest, sort = TRUE)

flights |>
  count(year, month, sort = TRUE)
```


```{r 3.2.5 Exercises}
flights |>
  filter(dep_delay >= 120)
flights |>
  filter(dest %in% c("IAH", "HOU")) 
flights |>
  filter(carrier %in% c("UA", "AA", "DL")) 
flights |>
  filter(month %in% c(6,7,8)) 
flights |>
  filter(arr_delay > 120 & dep_delay == 0)

flights |>
  arrange(desc(dep_delay))

flights |>
  arrange(dep_time) |>
  view()

flights |>
  arrange(arr_time - dep_time) |>
  relocate(dep_time, arr_time)

flights |>
  distinct(month, day) |>
  arrange(month, day) |>
  count() #  OR nrow()

flights |>
  arrange(desc(distance)) |>
  relocate(distance, origin, dest) # JFK to HNL

flights |>
  arrange(distance) |>
  relocate(distance, origin, dest) # EWR to PHL

# Order does not matter
```

```{r 3.3 Columns}

# mutate
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60
  ) |>
  relocate(gain, speed) 

# add to left hand side after mutating
# mutate
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    before = 1)  # equivalent to relocate gain, speed

#add after day variable, . is a sign that .before is an argument to the mutate function, not a variable name
flights |>
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .after = day
  )

# only keep affected variables
df_delay_gain <- flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )

df_delay_gain

# 3.3.2 select() 

#selet columns by name
flights |> 
  select(year, month, day, carrier)

# select all columns between variables
flights |> 
  select(flight:dest)

# select all columns except variables
flights |> 
  select(!year:day) # Historically this operation was done with - instead of !, so you’re likely to see that in the wild. These two operators serve the same purpose but with subtle differences in behavior. We recommend using ! because it reads as “not” and combines well with & and |.

# select all columns with characters
flights |> 
  select(where(is.character))

# rename variables
flights |> 
  select(tail_num = tailnum) # new name on left, old on right

# further oin relocation
flights |> 
  relocate(year:dep_time, .after = time_hour)
flights |> 
  relocate(starts_with("arr"), .before = dep_time) 


```

```{r 3.3.5 Exercises}

flights |> 
  select(dep_time, sched_dep_time, dep_delay) # dep_delay diff between dep_time and sched

flights |> 
  select(dep_time:dep_delay)

flights |> 
  select(starts_with("dep") | starts_with("arr"))

flights |> 
  select(month, month, month)

variables <- c("year", "month", "day", "dep_delay", "arr_delay")

flights |> 
  select(any_of(variables))
  
flights |> 
  select(contains("TIME")) # by default, case ignored

flights |> 
  rename(air_time_min = air_time) |> 
  relocate(air_time_min, .before = 1)

flights |> 
  select(tailnum) |> 
  arrange(arr_delay) # because tailnum was selected, so arr_delay was booted
```

```{r 3.4  Pipe and Groups}
flights |> 
  filter(dest == "IAH") |> 
  mutate(speed = distance / air_time * 60) |> 
  select(year:day, dep_time, carrier, flight, speed) |> 
  arrange(desc(speed))

flights |> 
  group_by(month)

# 3.5.2 summarize() 
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay) # uh oh, missing data!
  )

flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE)
  )

flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE), 
    n = n() # number of rows in each group
  )

# 3.5.3 The slice_ functions

# df |> slice_head(n = 1) takes the first row from each group.
# df |> slice_tail(n = 1) takes the last row in each group.
# df |> slice_min(x, n = 1) takes the row with the smallest value of column x.
# df |> slice_max(x, n = 1) takes the row with the largest value of column x.
# df |> slice_sample(n = 1) takes one random row.

flights |> 
  group_by(dest) |> 
  slice_max(arr_delay, n = 1) |> # takes the row with the largest value of column arr_delay
  relocate(dest) # Note that there are 105 destinations but we get 108 rows here. What’s up? slice_min() and slice_max() keep tied values so n = 1 means give us all rows with the highest value. If you want exactly one row per group you can set with_ties = FALSE.

flights |> 
  group_by(dest) |> 
  slice_max(arr_delay, n = 1, with_ties = F) |> # no ties, only one row per group
  relocate(dest)

# This is similar to computing the max delay with summarize(), but you get the whole corresponding row (or rows if there’s a tie) instead of the single summary statistic.

daily <- flights |>  
  group_by(year, month, day) # multiple group variables, each summary peels off the last group.
daily

daily_flights <- daily |> 
  summarize(n = n()) # explains how one group was peeled off (day), now only 2 left

daily_flights <- daily |> 
  summarize(
    n = n(), 
    .groups = "drop_last" # surpress warning about peeling offf groups
  )

# summarize ungrouped data
daily |> 
  ungroup() |>
  summarize( # only one row becuase ungrouped data is treated as one group
    avg_delay = mean(dep_delay, na.rm = TRUE), 
    flights = n()
  )

# 3.5.6 .by

flights |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    n = n(),
    .by = month # new and experimental
  )

# group by multiple variables
flights |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    n = n(),
    .by = c(origin, dest) # .by works with all verbs and has the advantage that you don’t need to use the .groups argument to suppress the grouping message or ungroup() when you’re done.
  )
```

```{r 3.5.7 Exercises}

flights |> 
  group_by(carrier, dest) |> 
  summarize(n())

flights |> 
  group_by(carrier) |> 
  summarize(
    avg_dep_delay = mean(dep_delay, na.rm = T)  
  ) |> 
  arrange(desc(avg_dep_delay)) # F9 (Frontier Airlines) has the worst delays

flights |> 
  group_by(dest) |> 
  slice_max(dep_delay, with_ties = F) |> 
  relocate(dest, dep_delay)

df_dep_time <- flights |> 
  group_by(hour) |> 
  summarize(
    avg_delay_time = mean(dep_delay, na.rm = T)
  ) 

ggplot(df_dep_time, aes(x=hour, y = avg_delay_time)) +
  geom_smooth()

flights |> 
  group_by(dest)
  slice_min(dep_delay, n = -1)
  
flights |> 
  count(carrier, sort = T) # roughly equivalent to df %>% group_by(a, b) %>% summarise(n = n()). count() 

df <- tibble(
  x = 1:5,
  y = c("a", "b", "a", "a", "b"),
  z = c("K", "K", "L", "L", "K")
)

df

# a, a, a, a, b

df |>
  group_by(y) # groups by y , thought output remains the same

# a, a, a, a, b

df |>
  arrange(y)

# two rows, mean of all a's, mean of all b's, two columns

df |>
  group_by(y) |>
  summarize(mean_x = mean(x))

# group by all combinatoins of y z, so a K, a L, b K
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))

# same\?
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x), .groups = "drop") # result is not grouped

df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x)) # show y z and summary mnean_x

df |>
  group_by(y, z) |>
  mutate(mean_x = mean(x)) # create new column plus all others 

```

```{r 3.6 Case study: aggregates and sample size}

batters <- Lahman::Batting |> 
  group_by(playerID) |> 
  summarize(
    performance = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    n = sum(AB, na.rm = TRUE)
  )
batters


batters |> 
  filter(n > 100) |> 
  ggplot(aes(x = n, y = performance)) +
  geom_point(alpha = 1 / 10) + 
  geom_smooth(se = FALSE)

batters |> 
  arrange(desc(performance))
```

